1. 아래의 코드에서 표현식인 부분과 표현식이 아닌 부분에 대해서 구분하시오

    ----------------------------표현식O
    x=100;
    console.log(a);
    var a = y = 100;
    ----------------------------표현식X
    var x;
    var foo = var x;

2.그렇다면 위에 설명과 같이 다 실수로 측정한다면 2진수, 8진수, 16진수를 출력하면 어떤식으로 될까?
    모두 65로 통일된 값이 출력됩니다.

3. 다 실수라면 아래의 비교문의 결과는 어떻게 나올까? 
    true
    2
    1.5

4.위에 세가지를 console을 이용하여 도출해보세요.
    console.log(1 / 0);
    console.log(-1 / 0);
    console.log(3 / 'b');

5.만약 NaN이 아닌 nan, NAN 같이 변수에 대입하면 어떤 식으로 나올까요?
    인터프리터가 받아들이지 못합니다.

6. “” 안의 ‘’(single quote)은 뭘로 인식되고 ‘’(single quote) 안의 “”은 뭘로 인식될까
    모두 문자로 인식된다. '' , "" 가 출력됩니다.


7. 그렇다면 아래의 코드는 어떤식으로 다를까?
    아래 코드는 위 코드와 다르게 템플릿 리터럴을 적용하지 않아 표현식이 그대로 문자열로 출력됩니다.

8. 의도적 부재를 왜 사용할까?
    PPT의 내용과 같이 개발자가 해당 변수에 대한 값을 아직 정하지 못했거나 나중에 할당하는 등의 이유로 할당하거나
    GC가 자동으로 해당 변수의 메모리를 해제 하도록 설정하도록 합니다.

9. 과연 아래의 사용법이 옳은 선택일까? 다른 방법으로 변수를 소멸시키는게 좋지 않을까?
    변수의 재사용 가능성이 없다면 해당 방식으로 메모리 사용을 해제하여 최적하하는 것이 좋아보입니다.

10. ECMAScript 사양은 문자열과 숫자 타입 외에는 명시적으로 규정하고 있지 않은데 그렇다면 해당 데이터 타입들 외에는 어떤 식으로 계산되고 있는가?
    (ECMAScript 사양서에 적혀있지 않은 타입의 사용 방법을 적는 방식으로 해석했습니다.)
    boolean     true, false로 조건문과 논리연산에서 사용합니다.
    undifined   변수가 선언되었지만 초기화, 할당되지 않았을 때 암묵적으로 할당되는 값입니다.
    null        의도적으로 값이 없음을 나타낼때 할당하는 값입니다.
    symbol      다른 데이터와 절대 중복되지 않는 데이터 타입입니다. 
                var a = Symbol('hi')

11.심벌 테이블 이라는 뜻을 알아보시오
    심볼 테이블(Symbol Table)은 (key, value)의 쌍을 저장하는 데이터 구조이며, 특히 key를 검색어로 주었을 때, 이에 대응하는 value를 빠르게 찾아주는 구조입니다.
    보통 식별자 관리에 사용되고 변수가 선언 됐을 때 변수 이름과 주소가 생성되는데 변수가 초기화되면 해당 변수의 주소에 값을 넣게됩니다.

13. 13.js 해당 코드 실행해보기

12. 대표적인 동적/정적 언어를 조사해보시오
    동적언어: python, JS
    정적언어: c, c++ ,java

14.암묵적 타입 변환 또는 타입 강제 변환에 대해서 알아보시오
    (묵시적)암묵적 타입 변환은 서로 다른 타입의 변수가 연산될 때 엔진이 필요에 따라 자동으로 데이터 타입을 변환시키는 것입니다.
    (명시적)타입 강제 변환은 개발자가 의도적으로 변수 타입을 변경하는 것입니다. 보통 변경할타입(변수) 형식으로 이루어집니다.

15. 아래의 비교가 뭐가 다른지 알아보시오.
    동등 비교와 일치 비교에 대한 차이를 설명하려는 코드 같습니다.
    첫번째 코드는 동등 비교이기 때문에 타입을 구분하지 않아 모두 true 입니다.
    두번째는 일치 비교이기 때문에 첫번째 라인만 true 두번째 라인은 false 입니다.
    세번째는 모두 동등 연산자를 사용합니다.
        문자열 0은 암묵적 형변환에 의해 ture 빈문자열은 false가 되어 false 가 됩니다.
        숫자 0은 false 빈문자열은 false가 되어 true 가 됩니다.
        숫자 0은 false 문자열 0은 숫자 0으로 형변환 된 후 boolean 으로 다시 변환되어 false 입니다. 결과는 ture 가 됩니다.
    네번째는 모두 동등 연산자를 사용합니다.
        false는 false입니다. 문자열 false는 내부의 값이 있음 없음을 판단해 ture를 반환합니다 결과는 false 입니다.
        false는 false입니다. 문자열 0은 위와 마찬가지로 ture를 반환합니다. 결과는 false 입니다.
        false는 false입니다. null은 false로 변환됩니다. 결과는 true 입니다.
    다섯번째
        일치 연산자를 사용했습니다. NaN은 정확하지 않은 연산의 수많은 원인을 하나의 결과(NaN)로 표현했기 때문에 자기자신도 부정확한 것으로 판단합니다. 결과는 false입니다.
        동등 연산자를 사용했습니다. 0과 -0은 같으므로 true입니다.
        일치 연산자를 사용했습니다. 0과 -0은 같고 숫자 타입도 일치하기 때문에 true입니다.

16. 결과가 왜 다를까?
    Object.is()메소드는 두 비교군의 컨텍스트까지 확인하며 일치 연산자보다 더 엄격한 비교를 수행하기 때문입니다.

17.위에 있는 반환 값을 다 나타내보시오.
    string      console.log(typeof('hi'));
    number      console.log(typeof(1));
    boolean     console.log(typeof(true));
    underfined  var a; console.log(typeof(a));
    symbol      var a = Symbol('key'); console.log(typeof(a));
    object      var a = new Object(); console.log(typeof (a));
    function    function a(){} console.log(typeof (a));

19. js로 백준 문제 풀어보기