1. 밑의 코드를 실행해보고 이유를 생각해보시오.
    slice 메소드에 파라미터를 넣지 않아서 새로 생성된게 아닌 기존 original의 메모리 주소만 복사 해버렸기 때문입니다.(얕은 복사)

2. 밑의 코드를 실행해보고 이유를 생각해보시오.
    두 코두 모두 Object.assign()에 대해 다루고 있습니다. 첫번째 코드는 1차원 객체만 다루고 있기 때문에 깊은 복사가 수행되어 
    newObj는 다른 주소를 참조하고 값만 복사한 상태입니다. 결과는 false입니다. 두번째 코드는 객체가 2차원으로 구성되어있어 2차원 객체는 얕은 복사가
    진행되어 true를 출력하고 있습니다. 이는 newObj를 다른 메모리 주소로 할당하긴 했지만 내부에 있는 newObj.b.c 는 여전히 메모리 주소를 가르키고 있는 참조를 복사해 왔기 때문입니다.


3. 밑의 코드를 실행해보고 이유를 생각해보시오.
    첫번째 코드는 1차원 배열이 깊은 복사가 되는 것을 보여주고
    두번째 코드는 spread 연산자 또한 2차원 이상 배열에서는 얕은 복사가 이루어 지는 것을 보여줍니다.
    마찬가지로 spread 연산자 또한 2차원 이상 객체는 참조 그 자체를 복사하기 때문에 얕은 복사가 진행됩니다.

4. 아래 함수를 작동 시켜보세오.

5.Lodash 라이브러리에 대해서 조사하고 cloneDeep 메서드도 조사해보세오
    자바스크립트의 라이브러리입니다. 여러 유틸리티 기능을 제공합니다. 배열 안의 여러 객체들을 핸들링 할 때 유용합니다. 특히 프론트엔드 환경에서 많이 사용됩니다.
    cloneDeep은 Lodash에서 제공하는 재귀형태의 함수입니다. 중첩된 속성들 또한 깊은 복사를 지원합니다.

6.소개한 방법 이외에도 깊은복사, 얕은복사 방법을 찾아보세요 가능하다면 언어 별로 정리해도 좋고, JS만 하셔도 좋고, 단일 언어 하나만 하셔도 좋습니다.
    JS
    얕은 복사
        Lodash또한 clone()메소드로 얕은 복사를 지원합니다.
        재귀를 이용하지 않은 for .. in .. 형태의 복사 함수

    깊은 복사
        rfdc의 clone : rfdc(Really Fast Deep Clone) 라이브러리의 clone() 함수를 이용해 깊은 복사를 할 수 있습니다. lodash보다 약 400% 빠른 깊은 복사를 수행합니다.4
        react, vue 등 라이브러리 이용

