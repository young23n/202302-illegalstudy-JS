1. Lexical Environment는 뭘 뜻하는 걸까?
    렉시컬 환경은 스크립트 전체, 실행중인 함수, 코드블록 등이 자신만의 렉시컬 환경 가지는 것 입니다.
    렉시컬 환경은 두가지로 나누어 지는데 환경 레코드와 외부 렉시컬 환경으로 나누어집니다.
    환경 레코드는 스코프 내에서 선언된 변수와 함수의 이름과 해당 값을 객체로 저장합니다.
    외부 렉시컬 환경현재 렉시컬 환경보다 더 상위의 렉시컬 환경입니다. 지역내에서 참조할 값이 없는 경우 외부 렉시컬 환경을 참조합니다.
    그럼에도 값이 없을 경우 더욱 상위 렉시컬 환경을 참조하는데 이것이 반복되는 것을 체이닝이라 합니다.


2. 아래 코드를 실행해 보시고 왜 저렇게 나오는지 설명하시오
    이는 스코프 때문입니다. foo()에서 x를 새로 초기화 한 것 처럼 보이지만 새로운 지역 변수x를 만든 것 뿐입니다.
    값을 초기화 할려면 변수를 생성하는 것이 아닌 x를 참조해 foo()가 상위 스코프를 이용하도록 해야합니다.
    마찬가지로 bar는 내부에 값이 없으니 상위 스코프를 참조하게 됩니다. 그러면 전역변수인 1뿐이니 모두 1만 출력이됩니다.


3. 아래 콘솔로그에서 뭐가 나올까? 돌려봅시다
    undefined
    globaaaaal
    호이스팅으로 인해 선언과 초기화는 undefined로 우선 실행되고 개발자가 의도한 초기화는 실제 초기화 코드의 행에 도착해야 작동하기 때문

4. 전역 객체란? 무엇인가?
    전역 객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 브라우저에서는 window, 서버(Node.js)에서는 global 객체를 의미합니다.

5. 아래 키워드로 사용 억제법을 한번 찾아보세오
변수의 스코프는 좁을수록 좋다고합니다. 지역변수를 지양하고 변수의 스코프를 줄이는 것
    1. 즉시 실행 함수
        "모든 코드"를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됩니다. 전역변수가 생길 수 없도록 구성하여 원천 차단
        (function(){
            var foo = 10; //즉시 실행함수의 지역 변수
            //..
        }());
    2. 네임스페이스 객체
        전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법
        var MYAPP = {} // 전역 네임스페이스 객체

        MYAPP.name = 'Lee';
        MYAPP.age = 10;

        console.log(MYAPP.name); // Lee
        console.log(MYAPP.age); // 10

        뭔가 클래스와 비슷하네요 각각의 객체의 프로퍼티만 불러와 충돌을 방지할 수 있을 것 같습니다.

    3. 모듈 패턴
        관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만드는 것입니다. 강력한 기능인 클로저를 기반으로 동작합니다.
        모듈 패턴의 특징은 전역 변수의 억제는 물론 캡슐화까지 구현 할 수 있다는 것입니다.
        외부에 노출하고 싶은 변수나 함수를 담아 반환하고, 노출되고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지 않는 방식 

        이러한 형식으로 의도된 방식으로 값을 변경하도록 하고 값에 직접적으로 접근하여 변경하는 것을 막습니다.
    
    4. ES6 모듈
        ES6 에서 파일 자체의 독자적인 모듈 스코프를 제공하기 시작했습니다. 이로인해 전역변수를 사용할 필요가 없게 되는데요 
        모듈은 애플리케이션을 구성하는 개별적 요소로 재사용 가능한 코드 조각입니다.(각각의 기능이 분리된 상태로 기본적으로 서로 접근할 수 없음)
        모듈에 포함된 요소들은 기본적으로 모두 캡슐화 되어 다른 모듈이 접근할 수 없습니다.
        export를 통해 모듈 일부 또는 전체를 공개할 수 있고 import를 통해 다른 모듈에서 공개된 모듈을 자신의 스코프로 불러들여 재사용할 수 있게됩니다.
        즉 모듈 각각이 자신만의 스코프를 가지게 되어 개발자가 재사용할 코드를 모두 명시적으로 설정을 해야하기 때문에 충돌, 예기치 못한 오류, 전역변수 사용을 방지할 수 있습니다.


6. 전역변수 + 지역변수 관련된 해석을 본인이 직접 최소 30줄 이상의 코드를 작성해서 서술해보세요




7. 아래 콘솔로그의 결과값을 추론해보세요.
    var x = 1;
    var y = 1;
    var x = 100;
    var y;
    console.log(x);
    console.log(y);
    -----------------
    x  100
    y  undefined

    근거: 3번에서 적은 것과 같이 호이스팅으로 인해 선언과 초기화는 undefined로 우선 실행되고 
          개발자가 의도한 초기화는 실제 초기화 코드의 행에 도착해야 작동하기 때문입니다. 
          선언된 var x = 100;와 var y;가 마지막으로 선언되어 이렇게 추론하였습니다.

          // y는 틀렸네요... 정확히는 모르겠지만 또 추론하자면 호이스팅으로 선언은 이미 끝났으니 var y; 이부분은 사실상 없는 것으로 보입니다.(이미 선언된걸 또 선언할 필요가 없으니)
          // 이후 코드행에서 1로 초기화되었고 1이 출력하는 형태인 것 같습니다.

8.  하단의 코드를 실행하고 에러가 난다면 왜 나는지 설명하시오

    let a = 1;
    {
        let a = 2;
        let b = 3;
    }
    console.log(a);
    console.log(b);

    블록문으로 감싸 변수 스코프에 의해 접근할 수 없기 때문입니다.

9. 지금까지 했던 코드를 기반으로 let, const 키워드를 적절히 사용해서 var 키워드 대신 써보세요