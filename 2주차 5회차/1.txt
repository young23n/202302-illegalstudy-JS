1. 아래의 빈칸과 서로 차이점을 서술하시오.
    매개변수, 파라미터
    인수

2. 본인이 생각하기에 이상적인 개발자는 어떤 형태인가?
해당 질문에 대해서 진지하게 한번쯤은 고민할 만 합니다. 보통 프로그래머
로 취업을 한다면 인터뷰에서 무조건 물어보는 내용이기도 합니다.

    협업을 잘하는 개발자입니다. 단순히 협업 툴 사용, 조직내 소통 뿐 아니라 디자인, 기획, 다른 분야의 개발자가
    서로의 문제점을 알며 이해할 수 있고 함께 문제를 해결하는 것을 잘하는 개발자인 것 같습니다. 이를 위해서는
    다른 분야까지 잘 알고 있어야 하니 어떻게 보면 제너럴리스트가 이러한 면이 있는 것 같습니다.

3. 선언문에서는 함수 이름을 생략할 수 없다. 만약 함수 이름을 생략하면 나오는 에러는 어떤건지 확인해보세오.

    함수 이름이 필요하다는 문법 오류가 생깁니다.

4. { } 는 블록문일까 객체 리터럴일까? 본인의 생각을 쓰고 그 이유에 대해서 서술하시오.
    쓰임에 따라 달라집니다. 
    사용되는 목적 쓰임에 주변 코드의 문맥에 따라 객체 리터럴, 블록문 둘다 가능하기 때문입니다.

5. 하단의 에러는 왜 날까?
    생성자 함수에 a 가 선언되지 않았기 때문입니다. 선언하더라도 매개변수 목록을 나열할 뿐이라 함수를 호출할 때 a 변수를 직접 할당하여야합니다.
    전역변수가 아니어서 할당도 불가능하지만...

6. 아래 함수를 실행해보고 결과 값을 적으시오.
    ReferenceError: x is not defined
    
    NaN
    
    [Arguments] { '0': 2, '1': 5, '2': 10 }
    7

7. 재귀함수로 팩토리얼을 구현해보시오. 그리고 해당 코드에 대한 리뷰를 해보세요.
    주석을 추가하였습니다.

8. callback 지옥이라는 말이 유명하다. 직접 지옥을 만들어보자. 그리고 calllback 지옥이 왜 위험한지 서술하시오. 
    이유는 코드의 가독성이 떨어져 코드의 수정이 어려워집니다. 이로인에 문제가 어디서 일어났는지 알기 힘들고 프로그램의 유지보수에도 나쁜영향을 줍니다.

9. 아래의 코드 중 어떤 것이 순수 함수이며 어떤 것이 비순수 함수인지 서술하시오
    첫번째 코드가 순수함수이고 두번째 코드는 비순수함수입니다.
    첫번째 코드는 n에 같은 값을 넣으면 항상 동일한 값이 나오게 됩니다.
    두번째 코드는 전역 변수 count를 직접 변경하고 있습니다.

10. commonJS와 ES6의 차이점을 조사해보자.
    모듈 시스템 접근방식의 차이점이 존재합니다.
    commonJS는 묘듈을 동기적으로 불러오고 내보냅니다. ES6의 경우 비동기적으로 로딩됩니다.
    또한 commonJS와는 다르게 실제 사용하는 부분만 가져와 사용할 수 있어 메모리를 적게 차지하는 등 최적화 면에서 이점이 있습니다.

11. callback 지옥을 해결하기 위한 예방법 혹은 대체법 찾아오기.
    Promise와 async/await가 있습니다.
    promise는 비동기 연산이 종료된 이후에 결과를 알기 위해 사용하는 객체입니다. 비동기 메서드를 마치 동기 메서드처럼 값을 반환할 수 있습니다
    async/await는 비동기 작업을 동기 작업처럼 작업이 완료될 때까지 대기할 수 있습니다. async을 통해 함수를 선언하고 await로 작업을 완료할 때까지 대기합니다. 

12. function를 사용해서 120줄 이상 어떤 function는 리턴값 주고, callback이 들어가야 함. 재귀도 들어가야 함. 화살표 함수도 넣어보자.